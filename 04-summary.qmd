# Data Summaries {#sec-summary}

THIS CHAPTER IS CURRENTLY UNDERGOING REVISION

## Intended Learning Outcomes {#sec-ilo-summary .unnumbered}

* Be able to summarise data by groups
* Be able to produce well-formatted tables
* Use pipes to chain together functions

## Walkthrough video {#sec-walkthrough-summary .unnumbered}

There is a walkthrough video of this chapter available via [Echo360](). Please note that there may have been minor edits to the book since the video was recorded. Where there are differences, the book should always take precedence.


## Set-up {#sec-setup-summary}

First, create a new project for the work we'll do in this chapter named `r path("04-summary")`. Second, download the data for this chapter (<a href="data/12.1_delivery.csv" download>12.1_delivery.csv</a>) and save it in your project data folder. Finally, open and save and new R Markdown document named `summary.Rmd`, delete the welcome text and load the required packages for this chapter.

```{r setup-summary, message=FALSE, verbatim="r setup, include=FALSE"}
library(tidyverse)   # data wrangling functions
library(kableExtra)  # for nice tables
```

Download the [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).

## Import Data

The data we'll be working with is on method of delivery for singleton births from Public Health Scotland. You can see the most recent version at [Method of Delivery](https://www.opendata.nhs.scot/dataset/births-in-scottish-hospitals/resource/8654b6d8-9765-4ced-8e9b-4611aa4596eb), but we'll be working from a saved version. 

The data are in a `glossary("CSV")` file, so we can read this with the function `read_csv()` , and assign it to a new object that we'll call `births`.

```{r, message=TRUE}
births <- read_csv("data/12.1_delivery.csv")
```

When you load data with `read_csv()`, you get a quick summary that you should always check to see if the data were loaded correctly. One common problem is that data load with the the wrong type (see @sec-data-types). The abbreviation "chr" means this is a `r glossary("character")` column, which can contain any text. The abbreviation "dbl" is a `r glossary("double")`, which is a number that can have decimal places. There are too many columns to show here, so it tells you to use the `spec()` function to check all the columns. 

```{r}
spec(births)
```


You can also use the `glimpse()` function to check the type of each column, and see a few examples of the cell values. 

```{r}
glimpse(births)
```

The column `SIMDQuintileQF` looks a little odd. We can quickly check what all the values are in a data table with the `count()` function:

```{r}
count(births, SIMDQuintileQF)
```


It looks like this column doesn't contain any useful info, so we can just ignore it, or skip it using the `col_types` argument and two helper functions, `cols()` and `col_skip()`. Setting the `col_types` argument also removes the message about column types.

```{r}
births <- read_csv("data/12.1_delivery.csv",
                   col_types = cols(SIMDQuintileQF = col_skip()))
```

You can learn more about importing data in @sec-data

### Exploring a Dataset 

There are `r nrow(delivery)` rows and `r ncol(delivery)` columns of data. The data dictionary on the NHS website includes the following, but doesn't clearly state what the possible values are for each column. We're going to practice figuring out more about how data is structured using data summaries in this exercise, since it's a common task to get a mysteriously formatted data file and need to figure it out yourself. At the very least, this exercise should remind you to never do this to other people -- always provide a clear codebook with all values! 

Column | Type | Label
:------|:-----|:-----
FinancialYear     | text | Data is recorded for financial years (1st April to 31st March) based on the date of the mother's discharge
CA                | text | 9-digit code for Council areas based on boundaries as at 1st April 2019
SIMDQuintile      | text | Scottish Index of Multiple Deprivation (SIMD) quintile; 1(Most Deprived) - 5(Least Deprived)
SIMDQuintileQF    | text | Qualifier for SIMDQuintile indicating unknown quintiles
SIMDVersion       | text | Most appropriate SIMD release used for each year
AgeGroup          | text | Age Group of the mother at time of admission
Delivery          | text | The method by which the baby was delivered
Induced           | text | Was the delivery induced, that is, was it started artificially
Livebirths        | numeric |Number of live births

### The $ operator

We need to take a couple of brief detours to introduce some additional coding conventions. First, let's introduce the `$` notation. The dollar sign allows you to select items from an object, such as columns from a table. The left-hand side is the object, and the right-hand side is the item. When you call a column like this, R will return all the observations in that column.

```{r}
years <- births$FinancialYear
```

If your item has multiple observations, you can specify which ones to return using square brackets `[]` and the row number or a `r glossary("vector")` of row numbers.

```{r}
births$FinancialYear[1] # select one observation
births$AgeGroup[c(20,30,40)] # select multiple with c()
```

### Pipes {#sec-pipes-first}

Let's say you want to filter the dataset down to just the emergency C-sections, and then sum up the total number of live births per year, and then arrange the data from largest to smallest (don't worry, we'll introduce these functions soon). You could do it by creating intermediate objects for each step:

```{r}
c_sections <- filter(births, Delivery == "Caesarean - Emergency")
c_per_year <- summarise(c_sections, n = sum(Livebirths), .by = FinancialYear)
c_sorted <- arrange(c_per_year, desc(n))

c_sorted
```

Whilst the above code is functional, it adds three unnecessary objects to the environment, increasing the risk we'll use one of these objects by mistake. Enter... the pipe.

Let's formally introduce the `r glossary("pipe")`, that weird `%>%` you may have seen. Pipes allow you to send the output from one function straight into another function. Specifically, they send the result of the function before `%>%` to be the first argument of the function after `%>%`. It can be useful to translate the pipe as "**and then**". It's easier to show than tell, so let's look at an example.

```{r}
              
c_per_year <- births %>% # start with the births table, and then
  # filter the table to just emergency c-sections
  filter(Delivery == "Caesarean - Emergency") %>% # and then
  # calculate the total number of births per year
  summarise(n = sum(Livebirths), .by = FinancialYear) %>% # and then
  # sort by n, descending
  arrange(desc(n))

c_per_year
```

Notice that  `filter()`, summarise()` and `arrange()` no longer need the first argument to be the data table, it is pulled in from the pipe above. The power of the pipe may not be obvious now, but it will soon prove its worth. 

## Counting

You can count categorical data with the `count()` function. This will give you a new table with each combination of the counted columns and a column called `n` containing the number of observations from that group. 

Let's figure out how entries there were per delivery type. The first argument is the name of the data table object, and the second argument is the name of the column we want to count.

```{r}
count(births, Delivery)
```

There are 7 types of deliveries, and the new column `n` tells you how many rows of the data table there are per type. 

We can check a combination of columns by adding more arguments. The table below shows the number of rows per age group and induction status, sorted by the number of rows. 

```{r}
count(births, AgeGroup, Induced, sort = TRUE)
```


```{r, echo = FALSE}
mcq1 <- c(answer = "`count(births, Induced, sort = TRUE)`", 
          x = "`count(Induced, births, sort = TRUE)`", 
          x = "`count(births, Induced)`", 
          x = "`count(Induced, births)`") %>%
  sample() %>%
  longmcq()
```

::: {.callout-note .try}
How would you create the table of counts below? 

```{r, echo = FALSE}
count(births, Induced, sort = TRUE)
```

`r mcq1`
:::

However, the numbers above are not the number of births, but rather the number of rows in the data set. The column `Livebirths` contains the number per each category, so we will need to add those numbers together to see the total number of births. 


## Summarise {#sec-summary-summarise}

The `summarise()` function from the <pkg>dplyr</pkg> package is loaded as part of the tidyverse and creates summary statistics. It creates a new table with columns that summarise the data from a larger table using summary functions. Check the [Data Transformation Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf) for various summary functions. Some common ones are: `n()`, `min()`, `max()`, `sum()`, `mean()`, and `quantile()`.

::: {.callout-warning}
If you get the answer `NA` from a summary function, that usually means that there are missing values in the columns you were summarising. We'll discuss this more in @sec-missing-values, but you can ignore missing values for many functions by adding the argument `na.rm = TRUE`.

```{r}
values <- c(1, 2, 4, 3, NA, 2)
mean(values) # is NA
mean(values, na.rm = TRUE) # removes NAs first
```
:::

This function can be used to answer questions like: How many total live births were there? What are the `r glossary("mean")` and `r glossary("median")` number of births per year? Let's start with a very simple example to calculate the total number of births:

* The first argument that `summarise()` takes is the data table you wish to summarise, in this case the object `delivery`.
* `summarise()` will create a new table. The column names of this new table will be the left hand-side arguments (e.g., `total_births`)
* The values of these columns are the result of the summary operation on the right hand-side.

```{r}
summarise(births,
          total_births = sum(Livebirths))
```


If you want to summarise by category, you can use the `.by` argument, as long as you have a version of dplyr that is 1.1.0 or above (if not, you can use the method in the next section).

```{r}
summarise(births,
          total_births = sum(Livebirths),
          .by = Delivery)
```

If you want to group by more than one column, use the `c()` function to group the column names.

```{r}
summarise(births,
          total_births = sum(Livebirths),
          .by = c(Delivery, Induced))
```



## Grouping {#sec-grouping}

You can also create summary values by group using a combination of `group_by()` and `summarise()`. The function `group_by()` takes an existing data table and converts it into a grouped table, where any operations that are subsequently performed on it are done "by group". 

It differs from the `.by` argument to `summarise()` in that it is persistent, so the table stays grouped until you explicitly remove the groups using the `ungroup()` functions, while the `.by` argument only applies to the function it is inside. Most of the code examples you'll see use this style, since the `.by` argument is fairly new.

```{r}
births %>%
  group_by(Delivery) %>%
  summarise(births = sum(Livebirths)) %>%
  ungroup()
```

::: {.callout-warning}
Make sure you call the `ungroup()` function when you are done with grouped functions. Failing to do this can cause all sorts of mysterious problems if you use that data table later assuming it isn't grouped.
:::


You might have noticed that the order of the table above is different from the order when using the `.by` argument of `summarise()`. This is because `group_by()` always sorts the values in the grouping columns in ascending order, while `.by` leaves them in the order they are first encountered in your data frame. Use the function `arrange()` to manually change order (see @sec-arrange).

```{r}
births %>%
  group_by(Delivery) %>%
  summarise(births = sum(Livebirths)) %>%
  ungroup() %>%
  arrange(desc(births)) # sort by number of births in descending order
```



### Multiple groupings

You can add multiple variables to `group_by()` to further break down your data. For example, the below gives us the number of births broken down by delivery type and year.

* Reverse the order of `Delivery` and FinancialYear` in `group_by()` to see how it changes the output.

```{r}
births %>%
  group_by(Delivery, FinancialYear) %>%
  summarise(n = sum(Livebirths)) %>%
  ungroup()
```

::: {.callout-warning}
You may get the following message when using `summarise()` after `group_by()`.

> `summarise()` has grouped output by 'Delivery'. You can override using the `.groups` argument.

Tidyverse recently added a message to remind you whether the `summarise()` function automatically ungroups grouped data or not (it may do different things depending on how it's used). You can set the argument `.groups` to "drop", "drop_last", "keep", or "rowwise" (see the help for `?summarise`), but it's good practice to explicitly use `ungroup()` when you're done working by groups, regardless. 
:::


### Filter and mutate

You can also use additional functions like `filter()` or `mutate()` after `group_by`. You'll learn more about these in @sec-wrangle but briefly:

* `filter()` keeps observations (rows) according to specified criteria, e.g., all values above 5, or all induced births.
* `mutate()` creates new variables (columns), or overwrites existing ones.

You can combine functions like this to get detailed insights into your data. For example, you can 

* filter your data to remove unknown ages and delivery types
* count the number of births per year, delivery type, and age group
* recode the financial year into just the first year, and make it numeric

```{r}
births_per_year_type_age <- births %>%
  filter(AgeGroup != "Unknown",
         Delivery != "Not Known") %>%
  summarise(n = sum(Livebirths),
            .by = c(FinancialYear, Delivery, AgeGroup)) %>%
  mutate(year = str_extract(FinancialYear, ".{4}"),
         year = as.integer(year))

# show just the first 6 rows
head(births_per_year_type_age)
```

Now you can use your skills from @sec-viz to plot the data!

```{r fig-birth-year-type-age, fig.cap = ""}
ggplot(births_per_year_type_age, 
       aes(x = year, y = n, color = AgeGroup)) +
  geom_line() +
  facet_wrap(~Delivery, scales = "free_y") +
  labs(x = NULL, 
       y = "Number of Live Births per Year",
       color = "Age Group") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```







## Exercises

That was an intensive chapter! Take a break and then try one (or more) of the following:

* hat other insights can you generate about the birth data?
* Read through the [kableExtra](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html) vignettes and apply your own preferred table style.
* Work through the first few chapters of [Tidy Text](https://www.tidytextmining.com/index.html){target="_blank"} to see how you can work with and analyse text. In particular, see if you can conduct a sentiment analysis on the tweet data.

### Share on Teams

Once you're done, share your knitted report and the Rmd file on Teams in the Week 04 channel.

## Glossary {#sec-glossary-summary}

```{r, echo = FALSE, results='asis'}
glossary_table(as_kable = FALSE) |> 
  kableExtra::kable(row.names = FALSE, escape = FALSE) |>
  unclass() |> cat()
```

## Further resources {#sec-resources-summary}

* [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)
* [Chapter 3: Data Transformation ](https://r4ds.hadley.nz/data-transform) in *R for Data Science*
* [kableExtra vignettes](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html)
